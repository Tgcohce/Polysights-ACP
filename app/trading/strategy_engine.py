"""
Trading Strategy Engine for ACP Polymarket Trading Agent.

This module implements various trading strategies including arbitrage, 
momentum, mean reversion, event-driven, and smart money tracking.
Each strategy is implemented as a separate class with a common interface.
"""
import asyncio
import time
from abc import ABC, abstractmethod
from datetime import datetime, timedelta
from enum import Enum
from typing import Dict, List, Any, Optional, Tuple, Set
import uuid

from loguru import logger
from pydantic import BaseModel, Field

from app.polymarket.client import PolymarketClient
from app.polysights.client import PolysightsClient
from app.trading.market_analyzer import MarketAnalyzer
from app.wallet.erc6551 import SmartWallet
from app.utils.config import config


class StrategyType(str, Enum):
    """Trading strategy types."""
    ARBITRAGE = "arbitrage"
    MOMENTUM = "momentum"
    MEAN_REVERSION = "mean_reversion"
    EVENT_DRIVEN = "event_driven"
    SMART_MONEY = "smart_money"


class TradeDirection(str, Enum):
    """Trade direction."""
    BUY = "buy"
    SELL = "sell"
    NONE = "none"


class ExecutionPriority(str, Enum):
    """Priority for trade execution."""
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"


class TradeSignal(BaseModel):
    """
    Trading signal generated by a strategy.
    
    This model represents a trading opportunity identified
    by a strategy with execution details.
    """
    signal_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    strategy_type: StrategyType
    market_id: str
    outcome_id: str
    direction: TradeDirection
    price: float
    size: float
    confidence: float  # 0.0 to 1.0
    priority: ExecutionPriority
    expiry: datetime
    reason: str
    timestamp: datetime = Field(default_factory=datetime.now)
    metadata: Dict[str, Any] = Field(default_factory=dict)
    source_data: Dict[str, Any] = Field(default_factory=dict)


class TradeExecution(BaseModel):
    """
    Trade execution result.
    
    This model represents the result of a trade execution
    from a signal.
    """
    execution_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    signal_id: str
    transaction_id: Optional[str] = None
    executed_price: Optional[float] = None
    executed_size: Optional[float] = None
    status: str  # "pending", "executed", "failed", "canceled"
    timestamp: datetime = Field(default_factory=datetime.now)
    error: Optional[str] = None
    execution_time_ms: Optional[int] = None


class RiskParameters(BaseModel):
    """
    Risk management parameters.
    
    This model defines the risk constraints for trading
    strategies.
    """
    max_position_size: float = 1000.0
    max_position_percentage: float = 0.1  # Max 10% of portfolio in a single position
    max_daily_loss: float = 500.0
    stop_loss_percentage: float = 0.05  # 5% stop loss
    take_profit_percentage: float = 0.1  # 10% take profit
    max_slippage: float = 0.02  # Maximum acceptable slippage (2%)
    position_sizing_factor: float = 0.02  # Position sizing based on confidence and volatility
    max_concurrent_positions: int = 10
    min_confidence: float = 0.7  # Minimum confidence to enter a position


class StrategyParameters(BaseModel):
    """
    Base class for strategy parameters.
    
    Subclasses implement strategy-specific parameters.
    """
    pass


class ArbitrageParameters(StrategyParameters):
    """Parameters for arbitrage strategy."""
    min_profit_threshold: float = 0.01  # 1% minimum profit
    max_price_discrepancy: float = 0.1  # Maximum price difference to consider
    max_execution_time_seconds: float = 5.0  # Must execute quickly
    min_liquidity_factor: float = 2.0  # Ensure enough liquidity


class MomentumParameters(StrategyParameters):
    """Parameters for momentum strategy."""
    lookback_periods: List[int] = [5, 15, 30]  # Minutes
    momentum_threshold: float = 0.02  # 2% price change
    volume_factor: float = 1.5  # Volume increase factor
    trend_confirmation_periods: int = 3
    mean_reversion_filter: bool = True  # Filter out overbought/oversold


class MeanReversionParameters(StrategyParameters):
    """Parameters for mean reversion strategy."""
    window_size: int = 60  # Periods for calculating mean
    deviation_threshold: float = 2.0  # Standard deviations from mean
    half_life: int = 30  # Half life for mean reversion expectation
    zscore_entry: float = 2.0  # Z-score for entry
    zscore_exit: float = 0.5  # Z-score for exit


class EventDrivenParameters(StrategyParameters):
    """Parameters for event-driven strategy."""
    event_types: List[str] = ["news", "social", "onchain"]
    sentiment_threshold: float = 0.7  # Minimum sentiment score
    volume_spike_threshold: float = 3.0  # Volume spike factor
    reaction_time_seconds: float = 30.0  # Time to react after event
    confirmation_sources: int = 2  # Number of sources to confirm


class SmartMoneyParameters(StrategyParameters):
    """Parameters for smart money tracking strategy."""
    whale_threshold: float = 5000.0  # USD value to consider a whale
    follow_threshold: float = 3  # Follow after N whales move in same direction
    time_window_minutes: int = 60  # Time window to track smart money
    min_wallet_age_days: int = 30  # Minimum wallet age to consider smart


class TradingStrategy(ABC):
    """
    Abstract base class for all trading strategies.
    
    Each strategy implementation must inherit from this base class
    and implement the required methods.
    """
    
    def __init__(
        self,
        polymarket_client: PolymarketClient,
        polysights_client: PolysightsClient,
        market_analyzer: MarketAnalyzer,
        wallet: SmartWallet,
        risk_params: Optional[RiskParameters] = None,
        strategy_params: Optional[StrategyParameters] = None
    ):
        """
        Initialize the strategy.
        
        Args:
            polymarket_client: Client for Polymarket API
            polysights_client: Client for Polysights API
            market_analyzer: Market analyzer for market data and analysis
            wallet: Smart wallet for trade execution
            risk_params: Risk management parameters
            strategy_params: Strategy-specific parameters
        """
        self.polymarket_client = polymarket_client
        self.polysights_client = polysights_client
        self.market_analyzer = market_analyzer
        self.wallet = wallet
        self.risk_params = risk_params or RiskParameters()
        self.strategy_params = strategy_params or self._default_params()
        
        self.active = False
        self.monitoring_task = None
        
        # Performance tracking
        self.signals_generated = 0
        self.trades_executed = 0
        self.successful_trades = 0
        self.failed_trades = 0
        self.total_profit_loss = 0.0
        self.performance_history = []
    
    @abstractmethod
    def _default_params(self) -> StrategyParameters:
        """Return default parameters for this strategy."""
        pass
    
    @abstractmethod
    async def analyze_market(self, market_id: str) -> List[TradeSignal]:
        """
        Analyze a market and generate trade signals.
        
        Args:
            market_id: ID of the market to analyze
            
        Returns:
            List of trade signals
        """
        pass
    
    @abstractmethod
    def strategy_type(self) -> StrategyType:
        """Return the strategy type."""
        pass
    
    async def start(self):
        """Start the strategy."""
        if self.active:
            return
        
        self.active = True
        logger.info(f"Starting {self.strategy_type()} strategy")
        self.monitoring_task = asyncio.create_task(self._monitor_markets())
    
    async def stop(self):
        """Stop the strategy."""
        if not self.active:
            return
        
        logger.info(f"Stopping {self.strategy_type()} strategy")
        self.active = False
        
        if self.monitoring_task:
            self.monitoring_task.cancel()
            try:
                await self.monitoring_task
            except asyncio.CancelledError:
                pass
    
    async def _monitor_markets(self):
        """Monitor markets for opportunities."""
        try:
            while self.active:
                # Get active markets
                markets = await self.polymarket_client.get_active_markets()
                
                # Process each market
                for market in markets:
                    try:
                        market_id = market.get("id")
                        signals = await self.analyze_market(market_id)
                        
                        # Process signals
                        for signal in signals:
                            # Apply risk management
                            if self._validate_risk(signal):
                                # Execute trade
                                execution = await self._execute_signal(signal)
                                
                                # Track performance
                                await self._track_performance(signal, execution)
                    except Exception as e:
                        logger.error(f"Error processing market {market.get('id')}: {e}")
                
                # Wait before next iteration
                await asyncio.sleep(config.trading.strategy_update_interval_seconds)
        except asyncio.CancelledError:
            logger.info(f"{self.strategy_type()} market monitoring stopped")
        except Exception as e:
            logger.error(f"Error in {self.strategy_type()} market monitoring: {e}")
    
    def _validate_risk(self, signal: TradeSignal) -> bool:
        """
        Apply risk management rules to a signal.
        
        Args:
            signal: Trade signal to validate
            
        Returns:
            True if the signal passes risk validation
        """
        # Check minimum confidence
        if signal.confidence < self.risk_params.min_confidence:
            logger.debug(f"Signal {signal.signal_id} rejected: confidence {signal.confidence} below threshold {self.risk_params.min_confidence}")
            return False
        
        # Check maximum position size
        if signal.size > self.risk_params.max_position_size:
            logger.debug(f"Signal {signal.signal_id} rejected: size {signal.size} exceeds max {self.risk_params.max_position_size}")
            return False
        
        # Check current exposure to market
        # In a real implementation, we would check portfolio exposure
        # This is a simplified placeholder
        
        # Additional risk checks would be implemented here
        # Including portfolio concentration, max drawdown, etc.
        
        return True
    
    async def _execute_signal(self, signal: TradeSignal) -> TradeExecution:
        """
        Execute a trade signal.
        
        Args:
            signal: Trade signal to execute
            
        Returns:
            Trade execution result
        """
        execution = TradeExecution(
            signal_id=signal.signal_id,
            status="pending"
        )
        
        logger.info(f"Executing {self.strategy_type()} signal {signal.signal_id} for market {signal.market_id}: {signal.direction} {signal.size} @ {signal.price}")
        
        start_time = time.time()
        
        try:
            # Execute trade based on direction
            if signal.direction == TradeDirection.BUY:
                result = await self.polymarket_client.place_order(
                    market_id=signal.market_id,
                    outcome_id=signal.outcome_id,
                    side="buy",
                    size=signal.size,
                    price=signal.price
                )
            elif signal.direction == TradeDirection.SELL:
                result = await self.polymarket_client.place_order(
                    market_id=signal.market_id,
                    outcome_id=signal.outcome_id,
                    side="sell",
                    size=signal.size,
                    price=signal.price
                )
            else:
                raise ValueError(f"Invalid trade direction: {signal.direction}")
            
            # Update execution with result
            execution.transaction_id = result.get("transaction_hash")
            execution.executed_price = result.get("executed_price")
            execution.executed_size = result.get("executed_amount")
            execution.status = "executed"
            execution.execution_time_ms = int((time.time() - start_time) * 1000)
            
            self.trades_executed += 1
            self.successful_trades += 1
            
        except Exception as e:
            logger.error(f"Error executing signal {signal.signal_id}: {e}")
            execution.status = "failed"
            execution.error = str(e)
            execution.execution_time_ms = int((time.time() - start_time) * 1000)
            
            self.trades_executed += 1
            self.failed_trades += 1
        
        return execution
    
    async def _track_performance(self, signal: TradeSignal, execution: TradeExecution):
        """
        Track performance of executed trade.
        
        Args:
            signal: The original trade signal
            execution: The execution result
        """
        if execution.status != "executed":
            return
        
        try:
            # Calculate P&L (simplified)
            if execution.executed_price and execution.executed_size:
                # This is a simplified P&L calculation
                # In a real implementation, we would track position entry and exit
                # and calculate realized P&L
                
                entry_value = execution.executed_price * execution.executed_size
                
                # Record trade for performance tracking
                performance_entry = {
                    "signal_id": signal.signal_id,
                    "execution_id": execution.execution_id,
                    "strategy_type": self.strategy_type(),
                    "market_id": signal.market_id,
                    "direction": signal.direction,
                    "confidence": signal.confidence,
                    "entry_price": execution.executed_price,
                    "entry_size": execution.executed_size,
                    "entry_value": entry_value,
                    "entry_time": execution.timestamp,
                    "status": "open"
                }
                
                self.performance_history.append(performance_entry)
                
        except Exception as e:
            logger.error(f"Error tracking performance for signal {signal.signal_id}: {e}")
    
    def get_performance_metrics(self) -> Dict[str, Any]:
        """
        Get performance metrics for the strategy.
        
        Returns:
            Dictionary of performance metrics
        """
        win_rate = 0.0
        if self.trades_executed > 0:
            win_rate = self.successful_trades / self.trades_executed
        
        return {
            "strategy_type": self.strategy_type(),
            "signals_generated": self.signals_generated,
            "trades_executed": self.trades_executed,
            "successful_trades": self.successful_trades,
            "failed_trades": self.failed_trades,
            "win_rate": win_rate,
            "total_profit_loss": self.total_profit_loss,
            # Additional metrics would be added here
        }


class ArbitrageStrategy(TradingStrategy):
    """
    Arbitrage trading strategy.
    
    Identifies price discrepancies between different markets or outcomes
    and executes trades to capture risk-free profits.
    """
    
    def _default_params(self) -> StrategyParameters:
        return ArbitrageParameters()
    
    def strategy_type(self) -> StrategyType:
        return StrategyType.ARBITRAGE
    
    async def analyze_market(self, market_id: str) -> List[TradeSignal]:
        """
        Analyze a market for arbitrage opportunities.
        
        Args:
            market_id: ID of the market to analyze
            
        Returns:
            List of trade signals for arbitrage opportunities
        """
        signals = []
        
        try:
            # Get market data
            market_data = await self.polymarket_client.get_market(market_id)
            if not market_data:
                return signals
            
            # Get order book data
            order_book = await self.polymarket_client.get_order_book(market_id)
            if not order_book:
                return signals
            
            # Get outcomes
            outcomes = market_data.get("outcomes", [])
            if not outcomes or len(outcomes) < 2:
                return signals
            
            # Check for no-arbitrage condition (sum of probabilities = 1)
            params = self.strategy_params
            if not isinstance(params, ArbitrageParameters):
                params = ArbitrageParameters()
            
            # Calculate best bid/ask for each outcome
            outcome_prices = {}
            for outcome in outcomes:
                outcome_id = outcome.get("id")
                outcome_bids = [o for o in order_book.get("bids", []) if o.get("outcome_id") == outcome_id]
                outcome_asks = [o for o in order_book.get("asks", []) if o.get("outcome_id") == outcome_id]
                
                best_bid = max(outcome_bids, key=lambda x: x.get("price", 0), default={"price": 0})
                best_ask = min(outcome_asks, key=lambda x: x.get("price", 0), default={"price": 1})
                
                outcome_prices[outcome_id] = {
                    "bid": best_bid.get("price", 0),
                    "ask": best_ask.get("price", 0),
                    "bid_size": best_bid.get("size", 0),
                    "ask_size": best_ask.get("size", 0)
                }
            
            # Check for dutch-book arbitrage (sum of prices < 1)
            sum_of_bids = sum(data["bid"] for data in outcome_prices.values())
            
            if sum_of_bids < 1 - params.min_profit_threshold:
                # Dutch book opportunity found
                # Calculate optimal position sizes
                total_position_size = self.risk_params.max_position_size
                available_liquidity = min(data["bid_size"] for data in outcome_prices.values())
                position_size = min(total_position_size, available_liquidity)
                
                # Generate signal for each outcome
                for outcome_id, price_data in outcome_prices.items():
                    # Arbitrage opportunity - buy all outcomes
                    profit_margin = 1 - sum_of_bids
                    confidence = min(0.99, 0.7 + profit_margin * 5)  # Higher profit margin = higher confidence
                    
                    signal = TradeSignal(
                        strategy_type=StrategyType.ARBITRAGE,
                        market_id=market_id,
                        outcome_id=outcome_id,
                        direction=TradeDirection.BUY,
                        price=price_data["bid"],
                        size=position_size,
                        confidence=confidence,
                        priority=ExecutionPriority.HIGH,  # Arbitrage is high priority
                        expiry=datetime.now() + timedelta(minutes=5),  # Short expiry for arbitrage
                        reason=f"Dutch book arbitrage with {profit_margin:.4f} profit margin",
                        metadata={
                            "arbitrage_type": "dutch_book",
                            "profit_margin": profit_margin,
                            "sum_of_bids": sum_of_bids
                        },
                        source_data={
                            "outcome_prices": outcome_prices,
                            "order_book": order_book
                        }
                    )
                    signals.append(signal)
            
            # Check for cross-market arbitrage
            # This would involve comparing prices across different markets
            # For a similar event
            
            self.signals_generated += len(signals)
            return signals
            
        except Exception as e:
            logger.error(f"Error in arbitrage analysis for market {market_id}: {e}")
            return []


class MomentumStrategy(TradingStrategy):
    """
    Momentum trading strategy.
    
    Identifies and trades assets showing strong price movement
    in one direction based on recent price action.
    """
    
    def _default_params(self) -> StrategyParameters:
        return MomentumParameters()
    
    def strategy_type(self) -> StrategyType:
        return StrategyType.MOMENTUM
    
    async def analyze_market(self, market_id: str) -> List[TradeSignal]:
        """
        Analyze a market for momentum opportunities.
        
        Args:
            market_id: ID of the market to analyze
            
        Returns:
            List of trade signals for momentum opportunities
        """
        signals = []
        
        try:
            # Get market data
            market_data = await self.polymarket_client.get_market(market_id)
            if not market_data:
                return signals
            
            # Get historical data
            params = self.strategy_params
            if not isinstance(params, MomentumParameters):
                params = MomentumParameters()
            
            # Get price history
            max_lookback = max(params.lookback_periods)
            price_history = await self.polymarket_client.get_price_history(
                market_id=market_id,
                time_resolution="1m",
                limit=max_lookback + 10  # Add buffer
            )
            
            if not price_history or len(price_history) < max_lookback:
                return signals
            
            # Check each outcome for momentum
            for outcome in market_data.get("outcomes", []):
                outcome_id = outcome.get("id")
                outcome_history = [p for p in price_history if p.get("outcome_id") == outcome_id]
                
                if not outcome_history or len(outcome_history) < max_lookback:
                    continue
                
                # Calculate momentum indicators for different periods
                momentum_indicators = []
                for period in params.lookback_periods:
                    recent_prices = outcome_history[:period]
                    if len(recent_prices) < period:
                        continue
                        
                    start_price = recent_prices[-1].get("price", 0)
                    end_price = recent_prices[0].get("price", 0)
                    
                    if start_price <= 0:
                        continue
                        
                    price_change = (end_price - start_price) / start_price
                    momentum_indicators.append(price_change)
                
                if not momentum_indicators:
                    continue
                
                # Check for consistent momentum across periods
                avg_momentum = sum(momentum_indicators) / len(momentum_indicators)
                
                # Check if momentum exceeds threshold
                if abs(avg_momentum) > params.momentum_threshold:
                    # Check volume confirmation
                    recent_volume = sum(p.get("volume", 0) for p in outcome_history[:5])
                    earlier_volume = sum(p.get("volume", 0) for p in outcome_history[5:10])
                    
                    volume_increase = False
                    if earlier_volume > 0:
                        volume_ratio = recent_volume / earlier_volume
                        volume_increase = volume_ratio > params.volume_factor
                    
                    # Only generate signal if volume confirms momentum
                    if volume_increase:
                        direction = TradeDirection.BUY if avg_momentum > 0 else TradeDirection.SELL
                        confidence = min(0.95, 0.6 + abs(avg_momentum) * 5)
                        current_price = outcome_history[0].get("price", 0)
                        
                        # Determine position size based on confidence and volatility
                        price_volatility = self._calculate_volatility(outcome_history)
                        position_sizing_factor = self.risk_params.position_sizing_factor
                        position_size = self.risk_params.max_position_size * confidence * position_sizing_factor / max(0.01, price_volatility)
                        position_size = min(position_size, self.risk_params.max_position_size)
                        
                        signal = TradeSignal(
                            strategy_type=StrategyType.MOMENTUM,
                            market_id=market_id,
                            outcome_id=outcome_id,
                            direction=direction,
                            price=current_price,
                            size=position_size,
                            confidence=confidence,
                            priority=ExecutionPriority.MEDIUM,
                            expiry=datetime.now() + timedelta(hours=1),
                            reason=f"Momentum signal with {avg_momentum:.4f} price change over {len(momentum_indicators)} periods",
                            metadata={
                                "avg_momentum": avg_momentum,
                                "momentum_indicators": momentum_indicators,
                                "volume_ratio": volume_ratio if earlier_volume > 0 else 0,
                                "volatility": price_volatility
                            },
                            source_data={
                                "price_history": outcome_history[:max_lookback]
                            }
                        )
                        signals.append(signal)
            
            self.signals_generated += len(signals)
            return signals
            
        except Exception as e:
            logger.error(f"Error in momentum analysis for market {market_id}: {e}")
            return []
    
    def _calculate_volatility(self, price_history: List[Dict[str, Any]]) -> float:
        """
        Calculate price volatility from price history.
        
        Args:
            price_history: List of price data points
            
        Returns:
            Volatility measure
        """
        if not price_history or len(price_history) < 2:
            return 0.0
            
        prices = [p.get("price", 0) for p in price_history]
        returns = [prices[i]/prices[i+1] - 1 for i in range(len(prices)-1)]
        
        if not returns:
            return 0.0
            
        return (sum(r*r for r in returns) / len(returns)) ** 0.5  # Standard deviation of returns


class MeanReversionStrategy(TradingStrategy):
    """
    Mean Reversion trading strategy.
    
    Identifies assets that have deviated significantly from their
    historical mean and are expected to revert back.
    """
    
    def _default_params(self) -> StrategyParameters:
        return MeanReversionParameters()
    
    def strategy_type(self) -> StrategyType:
        return StrategyType.MEAN_REVERSION
    
    async def analyze_market(self, market_id: str) -> List[TradeSignal]:
        """
        Analyze a market for mean reversion opportunities.
        
        Args:
            market_id: ID of the market to analyze
            
        Returns:
            List of trade signals for mean reversion opportunities
        """
        signals = []
        
        try:
            # Get market data
            market_data = await self.polymarket_client.get_market(market_id)
            if not market_data:
                return signals
            
            # Get parameters
            params = self.strategy_params
            if not isinstance(params, MeanReversionParameters):
                params = MeanReversionParameters()
            
            # Get price history
            price_history = await self.polymarket_client.get_price_history(
                market_id=market_id,
                time_resolution="5m",
                limit=params.window_size + 10
            )
            
            if not price_history or len(price_history) < params.window_size:
                return signals
            
            # Check each outcome for mean reversion opportunities
            for outcome in market_data.get("outcomes", []):
                outcome_id = outcome.get("id")
                outcome_history = [p for p in price_history if p.get("outcome_id") == outcome_id]
                
                if not outcome_history or len(outcome_history) < params.window_size:
                    continue
                
                # Calculate mean and standard deviation
                prices = [p.get("price", 0) for p in outcome_history[:params.window_size]]
                mean_price = sum(prices) / len(prices)
                std_dev = (sum((p - mean_price) ** 2 for p in prices) / len(prices)) ** 0.5
                
                if std_dev <= 0:
                    continue
                
                # Get current price
                current_price = outcome_history[0].get("price", 0)
                
                # Calculate z-score (deviation from mean in terms of std devs)
                z_score = (current_price - mean_price) / std_dev
                
                # Check if price has deviated significantly from mean
                if abs(z_score) >= params.zscore_entry:
                    # Mean reversion signal - trade in opposite direction of deviation
                    direction = TradeDirection.SELL if z_score > 0 else TradeDirection.BUY
                    
                    # Higher deviation = higher confidence (up to a limit)
                    confidence = min(0.9, 0.6 + abs(z_score) * 0.1)
                    
                    # Calculate expected reversion target
                    reversion_target = mean_price + (z_score * std_dev * (1 - 1/params.half_life))
                    
                    # Calculate position size based on deviation and confidence
                    position_sizing_factor = self.risk_params.position_sizing_factor
                    position_size = self.risk_params.max_position_size * confidence * position_sizing_factor
                    position_size = min(position_size, self.risk_params.max_position_size)
                    
                    signal = TradeSignal(
                        strategy_type=StrategyType.MEAN_REVERSION,
                        market_id=market_id,
                        outcome_id=outcome_id,
                        direction=direction,
                        price=current_price,
                        size=position_size,
                        confidence=confidence,
                        priority=ExecutionPriority.MEDIUM,
                        expiry=datetime.now() + timedelta(hours=3),
                        reason=f"Mean reversion signal with z-score {z_score:.2f}",
                        metadata={
                            "z_score": z_score,
                            "mean_price": mean_price,
                            "std_dev": std_dev,
                            "reversion_target": reversion_target
                        },
                        source_data={
                            "price_history": outcome_history[:params.window_size]
                        }
                    )
                    signals.append(signal)
            
            self.signals_generated += len(signals)
            return signals
            
        except Exception as e:
            logger.error(f"Error in mean reversion analysis for market {market_id}: {e}")
            return []
